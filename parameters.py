import numpy as np

# Trajectory points
K = 50
iterations = 15
res = 100

# Mass
m_wet = 2.0
m_dry = 1.0

# Flight time guess
t_f_guess = 4.

# Weight constants
w_nu = 1e5
w_delta = 1e-3
w_delta_sigma = 1e-1

# State constraints
r_I_init = np.array((4., 4., 0.))
r_I_final = np.array((0., 0., 0.))
v_I_init = np.array((-1e-1, 0., 0.))
v_I_final = np.array((0., 0., 0.))
q_B_I_final = np.array((1.0, 0.0, 0.0, 0.0))
w_B_init = np.array((0., 0., 0.))
w_B_final = np.array((0., 0., 0.))
w_B_max = 60.

# Gravity
g_I = np.array((0., 0., -1.))
g1, g2, g3 = g_I

# Angles
cos_delta_max = np.cos(np.deg2rad(20))
cos_theta_max = np.cos(np.deg2rad(90))
tan_gamma_gs = np.tan(np.deg2rad(20))

# Angular momentum
J_B_I = np.array((1e-2, 1e-2, 1e-2))
J_B1, J_B2, J_B3 = J_B_I

# Vector from thrust point to CoM
r_T_B = np.array((-1e-2, 0., 0.))
r_T_B1, r_T_B2, r_T_B3 = r_T_B

# Thrust limits
T_min = 0.3
T_max = 5.0

alpha_m = 0.001


# Linearized state matrices

# A Matrix
def A(x, u, sigma_hat):
    return sigma_hat * np.array((
        (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
        (0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
        (0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0),
        (0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0),
        ((u[0] * (2 * x[9] ** 2 + 2 * x[10] ** 2 - 1)) / x[0] ** 2 - (u[1] * (2 * x[7] * x[10] + 2 * x[8] * x[9])) / x[
            0] ** 2 + (
                 u[2] * (2 * x[7] * x[9] - 2 * x[8] * x[10])) / x[0] ** 2, 0, 0, 0, 0, 0, 0,
         (2 * u[1] * x[10]) / x[0] - (
                 2 * u[2] * x[9]) / x[0], (2 * u[1] * x[9]) / x[0] + (2 * u[2] * x[10]) / x[0],
         (2 * u[1] * x[8]) / x[0] - (
                 4 * u[0] * x[9]) / x[0] - (2 * u[2] * x[7]) / x[0],
         (2 * u[1] * x[7]) / x[0] - (4 * u[0] * x[10]) / x[0] + (
                 2 * u[2] * x[8]) / x[0], 0, 0, 0),
        ((u[1] * (2 * x[8] ** 2 + 2 * x[10] ** 2 - 1)) / x[0] ** 2 + (u[0] * (2 * x[7] * x[10] - 2 * x[8] * x[9])) / x[
            0] ** 2 - (
                 u[2] * (2 * x[7] * x[8] + 2 * x[9] * x[10])) / x[0] ** 2, 0, 0, 0, 0, 0, 0, (2 * u[2] * x[8]) / x[0] - (
                 2 * u[0] * x[10]) / x[0],
         (2 * u[0] * x[9]) / x[0] - (4 * u[1] * x[8]) / x[0] + (2 * u[2] * x[7]) / x[0], (
                 2 * u[0] * x[8]) / x[0] + (2 * u[2] * x[10]) / x[0],
         (2 * u[2] * x[9]) / x[0] - (4 * u[1] * x[10]) / x[0] - (
                 2 * u[0] * x[7]) / x[0], 0, 0, 0),
        ((u[2] * (2 * x[8] ** 2 + 2 * x[9] ** 2 - 1)) / x[0] ** 2 - (u[0] * (2 * x[7] * x[9] + 2 * x[8] * x[10])) / x[
            0] ** 2 + (
                 u[1] * (2 * x[7] * x[8] - 2 * x[9] * x[10])) / x[0] ** 2, 0, 0, 0, 0, 0, 0, (2 * u[0] * x[9]) / x[0] - (
                 2 * u[1] * x[8]) / x[0],
         (2 * u[0] * x[10]) / x[0] - (2 * u[1] * x[7]) / x[0] - (4 * u[2] * x[8]) / x[0], (
                 2 * u[0] * x[7]) / x[0] + (2 * u[1] * x[10]) / x[0] - (4 * u[2] * x[9]) / x[0],
         (2 * u[0] * x[8]) / x[0] + (
                 2 * u[1] * x[9]) / x[0], 0, 0, 0),
        (0, 0, 0, 0, 0, 0, 0, 0, -x[11] / 2, -x[12] / 2, -x[13] / 2, -x[8] / 2, -x[9] / 2, -x[10] / 2),
        (0, 0, 0, 0, 0, 0, 0, x[11] / 2, 0, x[13] / 2, -x[12] / 2, x[7] / 2, -x[10] / 2, x[9] / 2),
        (0, 0, 0, 0, 0, 0, 0, x[12] / 2, -x[13] / 2, 0, x[11] / 2, x[10] / 2, x[7] / 2, -x[8] / 2),
        (0, 0, 0, 0, 0, 0, 0, x[13] / 2, x[12] / 2, -x[11] / 2, 0, -x[9] / 2, x[8] / 2, x[7] / 2),
        (
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (J_B2 * x[13] - J_B3 * x[13]) / J_B1, (J_B2 * x[12] - J_B3 * x[12]) / J_B1),
        (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -(J_B1 * x[13] - J_B3 * x[13]) / J_B2, 0,
         -(J_B1 * x[11] - J_B3 * x[11]) / J_B2),
        (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (J_B1 * x[12] - J_B2 * x[12]) / J_B3, (J_B1 * x[11] - J_B2 * x[11]) / J_B3, 0)
    ))


# B Matrix
def B(x, u, sigma_hat):
    return sigma_hat * np.array((
        (-(alpha_m * abs(u[0]) * np.sign(u[0])) / np.linalg.norm(u),
         -(alpha_m * abs(u[1]) * np.sign(u[1])) / np.linalg.norm(u),
         -(alpha_m * abs(u[2]) * np.sign(u[2])) / np.linalg.norm(u)),
        (0, 0, 0),
        (0, 0, 0),
        (0, 0, 0),
        (-(2 * x[9] ** 2 + 2 * x[10] ** 2 - 1) / x[0], (2 * x[7] * x[10] + 2 * x[8] * x[9]) / x[0],
         -(2 * x[7] * x[9] - 2 * x[8] * x[10]) / x[0]),
        (-(2 * x[7] * x[10] - 2 * x[8] * x[9]) / x[0], -(2 * x[8] ** 2 + 2 * x[10] ** 2 - 1) / x[0],
         (2 * x[7] * x[8] + 2 * x[9] * x[10]) / x[0]),
        ((2 * x[7] * x[9] + 2 * x[8] * x[10]) / x[0], -(2 * x[7] * x[8] - 2 * x[9] * x[10]) / x[0],
         -(2 * x[8] ** 2 + 2 * x[9] ** 2 - 1) / x[0]),
        (0, 0, 0),
        (0, 0, 0),
        (0, 0, 0),
        (0, 0, 0),
        (0, -r_T_B3 / J_B1, r_T_B2 / J_B1),
        (r_T_B3 / J_B2, 0, -r_T_B1 / J_B2),
        (-r_T_B2 / J_B3, r_T_B1 / J_B3, 0)
    ))


# f Matrix (x_dot)
def f(x, u):
    return np.array((
        -alpha_m * (abs(u[0]) ** 2 + abs(u[1]) ** 2 + abs(u[2]) ** 2) ** (1 / 2),
        x[4],
        x[5],
        x[6],
        (u[1] * (2 * x[7] * x[10] + 2 * x[8] * x[9])) / x[0] - (u[0] * (2 * x[9] ** 2 + 2 * x[10] ** 2 - 1)) / x[0] - (
                u[2] * (2 * x[7] * x[9] - 2 * x[8] * x[10])) / x[0],
        (u[2] * (2 * x[7] * x[8] + 2 * x[9] * x[10])) / x[0] - (u[0] * (2 * x[7] * x[10] - 2 * x[8] * x[9])) / x[0] - (
                u[1] * (2 * x[8] ** 2 + 2 * x[10] ** 2 - 1)) / x[0],
        (u[0] * (2 * x[7] * x[9] + 2 * x[8] * x[10])) / x[0] - (u[2] * (2 * x[8] ** 2 + 2 * x[9] ** 2 - 1)) / x[0] - (
                u[1] * (2 * x[7] * x[8] - 2 * x[9] * x[10])) / x[0] - 981 / 100,
        - (x[8] * x[11]) / 2 - (x[9] * x[12]) / 2 - (x[10] * x[13]) / 2,
        (x[7] * x[11]) / 2 + (x[9] * x[13]) / 2 - (x[10] * x[12]) / 2,
        (x[7] * x[12]) / 2 - (x[8] * x[13]) / 2 + (x[10] * x[11]) / 2,
        (x[7] * x[13]) / 2 + (x[8] * x[12]) / 2 - (x[9] * x[11]) / 2,
        (r_T_B2 * u[2] - r_T_B3 * u[1] + J_B2 * x[12] * x[13] - J_B3 * x[12] * x[13]) / J_B1,
        - (r_T_B1 * u[2] - r_T_B3 * u[0] + J_B1 * x[11] * x[13] - J_B3 * x[11] * x[13]) / J_B2,
        (r_T_B1 * u[1] - r_T_B2 * u[0] + J_B1 * x[11] * x[12] - J_B2 * x[11] * x[12]) / J_B3
    ))


def alpha(tk_1, t, tk):
    return (tk_1 - t) / (tk_1 - tk)


def beta(tk_1, t, tk):
    return (t - tk) / (tk_1 - tk)
